Emscripten: Bringing C and C++ to the Web
=========================================

# Introduction

Writing code for the browser in C / C++ and being able to port legacy codebases from those languages into the browser was one of the early drivers for asm.js and WebAssembly. It started with Emscripten, which is a complete compiler toolchain to WebAssembly, using LLVM. In the previous chapters, the examples with Clang and LLVM has for the most been without the standard library. With emscripten we can compile applications that use standard input/output, file systems, networking and other operating system features. The difference is that all of these OS features are provided from Javascript, in the browser or nodejs. When we can use such features, the selection of applications we can port to the web is large. With Emscripten we can materialize games and several advanced tools and applications on the web.

# Structure

- Compiling C and C++ with Emscripten
- Porting legacy code, linking static libraries
- Using Emscripten runtime APIs
- Wasi, the WebAssembly System Interface
- Using Wasi with the file system
- Interact with Javascript from within C / C++

# Objectives

In this chapter you will learn the basics of compiling with Emscripten. You will be able to use your existing knowledge about C / C++ compiler toolchain in the context of Emscripten and targeting the web browser. We will look into the limitations and ways of working around or overcoming them. This also includes platform specific code, where we have to reimplement parts of it for WebAssembly. Emscripten comes with a large Javascript based runtime, and we will look into the role of this. Features such as the file systems and network mechanisms are essential to understand. In the context of Javascript, you will also learn how to use synchronous code in an asynchronous context.

# Compiling C and C++ with Emscripten

Let us start with the basics. A simple hello world program. This is still very different from the examples in the previous chapters, where we have mainly returned numbers or filled buffers with data. We are now going to write to standard output, just like a regular console application. And so we can also write it in the regular way:

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("Hello %s\n", argv[argc-1]);
    return 0;
}
```

We can compile it, just like we compile with gcc:

`emcc -o helloworld.cjs helloworld.c`

Note that the output file is a commonjs Javascript file, that we can run with nodejs:

`node helloworld.cjs Peter`

which will simply output: `Hello Peter`

If we want to run this in a web-browser, we can change the output type:

`emcc -o helloworld.html helloworld.c`

And we get the html file `helloworld.html`, in addition to a Javascript and Wasm file. The html file is the entry point for the application, and it's a default html file template that is generated by emscripten, showing console output and a canvas. In most cases we would replace this with our own HTML file that imports the generated Javascript file, which executes the Wasm. What emscripten provides in the Javascript file is a full system layer with standard input and output, file system, networking and more, which is exposed to the WebAssembly binary. It is set up in the way that you should be able to write C or C++ programs in the same manner as for any other operating system, and Emscripten provides the web browser adapter in this Javascript file. This also make it quite a bit easier to port legacy codebases to the web.

Another example that demonstrates this, is drawing on a canvas using the SDL (Simple DirectMedia Layer) library. In a pure web environment we would rather use built-in methods of the HTML canvas element, but Emscripten lets us use the same code as we would have written for a native desktop app.

Here's a simple example drawing a rectangle:

```C
#include <SDL.h>

SDL_Window *window;
SDL_Renderer *renderer;

int main(int argc, char *argv[])
{
    SDL_Init(SDL_INIT_VIDEO);

    window = SDL_CreateWindow("SDL Rectangle",
                              SDL_WINDOWPOS_CENTERED,
                              SDL_WINDOWPOS_CENTERED,
                              640, 480,
                              SDL_WINDOW_SHOWN);

    // Create a renderer
    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);

    // Draw a rectangle
    SDL_Rect rect = {220, 140, 200, 200};
    SDL_RenderFillRect(renderer, &rect);
    SDL_RenderPresent(renderer);

    return 0;
}
```

We use the following command for compiling for web:

`emcc -sUSE_SDL=2 -o sdlhello.html sdlhello.c`

The resulting file `sdlhello.html` displays the rectangle in the canvas.

# Using familiar build automation tools as make or cmake

With Emscripten we can use the build automation tools we are used to from C and C++ development. The only difference is that we should use them together with the "helper" commands `emmake`, `emcmake` or `emconfigure` which will set environment variables so that the Emscripten compiler is used.

We will see the use of these build automation tools when porting legacy code below, and in the following chapters. In many cases we do not have to modify the `Makefile` or `CMakeFiles.txt` at all.

A minimum `Makefile` for a C++ program can look like this:

```Makefile
# Define the compiler and linker
CC = emcc

# Define the source files
SRCS = main.cpp

# Define the output file
OUTPUT = index.html

# Define compiler and linker flags
CFLAGS = -O2
LDFLAGS =

# Define the rule for building the project
all: $(OUTPUT)

# Define the rule for linking the project
$(OUTPUT): $(SRCS)
	$(CC) $(CFLAGS) $(SRCS) -o $(OUTPUT) $(LDFLAGS)

# Define the rule for cleaning up generated files
clean:
	rm -f $(OUTPUT)
```

Let us also create the simple C++ program in the file `main.cpp`:

```c++
#include <iostream>

int main() {
    std::cout << "Hello, Emscripten!" << std::endl;
    return 0;
}
```

To build with `make` we simply write `emmake` first, like this:

```bash
emmake make
```

The result are the files `index.html`, `index.js` and `index.wasm`, and by serving these files from a http server, we can load them into the web browser. We can use the `http-server` package from https://npmjs.io by typing into the terminal:

```bash
npx http-server .
```

If we now navigate to the URL that is displayed in the terminal output we can see our program running and showing the text "Hello, Emscripten".

The same approach with typing the helper command first, we can see also when using `./configure`, which we will see below, where we write `emconfigure ./configure` in the terminal. In the next chapter, we will use cmake, and then we write `emcmake cmake`.

# Porting legacy code, linking static libraries

Since we can use emscripten for porting legacy code, we will now apply this on a library for playing .mod files.

Let us clone the library `libxmp` which you can find at https://github.com/libxmp/libxmp

When cloned, we can follow the same flow as when using gcc for building C projects.

We start by running `./autogen.sh` for creating the `configure` file.

And then we build the static library:

```bash
emconfigure ./configure --enable-static --disable-shared --disable-it CFLAGS=-O3
emmake make
```

Now that we have a static library `libxmp.a`, we need functions to expose from a WebAssembly module. We will create another c file for this, that we will compile and link with the static library.

```c
#include <xmp.h>
#include "./src/common.h"
#include "emscripten.h"
#include <stdlib.h>

xmp_context ctx;
struct xmp_frame_info frame_info;
struct xmp_module_info module_info;

EMSCRIPTEN_KEEPALIVE
void * allocMemoryForModule(long size) {
    return malloc(size);
} 

EMSCRIPTEN_KEEPALIVE
void loadModule(void *mem, long size, int samplerate) {
    ctx = xmp_create_context();

    xmp_load_module_from_memory(ctx, mem, size);
    xmp_start_player(ctx, samplerate, 0);
}

EMSCRIPTEN_KEEPALIVE
void * playFrame()
{
    xmp_play_frame(ctx);
    xmp_get_frame_info(ctx, &frame_info);
    return &frame_info;
}
```

This c program exposes a function `allocMemoryForModule` for allocating memory for a module file that we would like to load and play. We use the `loadModule` function to parse the module we have copied into the WebAssembly runtime memory. Finally we use the `playFrame` function to generate PCM audio data that we can send to the audio device.

Here is how we compile and link with the static library.

`emcc -Wl,--no-entry -I./include lib/libxmp.a ./wasm-mod-player.c -O3 -o wasm-mod-player.wasm`

We should also remove some dead code, since we are only interested in a few functions. Let us create a json for `wasm-metadce`:

```json
[
    {
        "name": "allocMemoryForModule",
        "export": "allocMemoryForModule",
        "root": true
    },
    {
        "name": "loadModule",
        "export": "loadModule",
        "root": true
    },
    {
        "name": "playFrame",
        "export": "playFrame",
        "root": true
    },
    {
        "name": "memory",
        "export": "memory",
        "root": true
    }
]
```

And also run the dead code elimination:

`wasm-metadce -f wasm-mod-player-dce.json wasm-mod-player.wasm -o wasm-mod-player.wasm`

We can use the resulting wasm file `wasm-mod-player.wasm` in an HTML file that can play the module in the browser using Web Audio. The HTML file below contains a file upload element, and a script section that adds an event listener to this file upload element. When the selected file changes, the file data is read into a `Uint8Array`.

The next step is to instantiate the WebAssembly module. Note that for the imports we are providing a few `wasi_snapshot_preview1` functions and `env`. For all of these we just refer to a function `NOT_IMPLEMENTED` that just prints the message "not implemented". This is because we know that even though these functions are imported, they are not invoked by the parts of the wasm module we use.

After the WebAssembly module is instantiated we call its `allocMemoryForModule` function. Here we allocate memory corresponding to the size of the file we received from the file upload element. Since the Wasm module exports `memory` we can copy the contents of the file data array `modfiledata` directly into the WebAssembly memory to the address we got returned by the memory allocation call.

Now that we have the mod data in the memory of Wasm we can run `loadModule`, were we point to the memory address of the mod data, and also provide the sample rate for the web audio context.

The `playFragment` function calls the `playFrame` function of the Wasm module, which renders audio data into a memory buffer. We copy the contents of this memory buffer into an `AudioBuffer`, which we connect to an `AudioBufferSourceNode`, that we connect to the destination output of the `AudioContext`. Now we can hear the result from the speakers, and we keep on repeating calling the `playFragment` function, feeding the audio context with new sound fragments. By calculating the starttime of the next fragment to the exact duration of the current, the result is a continuous music output.

```html
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
    <input type="file" id="modfileinput">
</body>
<script type="module">
    const modfileinput = document.getElementById('modfileinput');
    let lastFileInputChangeEvent;
    modfileinput.addEventListener('change', async (fileInputChangeEvent) => {
        lastFileInputChangeEvent = fileInputChangeEvent;
        const file = modfileinput.files[0];
        const filereader = new FileReader();
        const modfiledata = await new Promise(resolve => {
            filereader.onload = e => resolve(new Uint8Array(e.target.result));
            filereader.readAsArrayBuffer(file);
        });
        const NOT_IMPLEMENTED = () => console.error('not implemented');

        const wasmExports = await WebAssembly.instantiateStreaming(fetch('wasm-mod-player.wasm'), {
            "wasi_snapshot_preview1": {
                "fd_close": NOT_IMPLEMENTED,
                "fd_write": NOT_IMPLEMENTED,
                "fd_seek": NOT_IMPLEMENTED,
                "fd_read": NOT_IMPLEMENTED,
                "clock_time_get": NOT_IMPLEMENTED
            },
            "env": {
                "__syscall_getdents64": NOT_IMPLEMENTED,
                "__syscall_unlinkat": NOT_IMPLEMENTED
            }
        }).then(mod => mod.instance.exports);

        const memaddr = wasmExports.allocMemoryForModule(modfiledata.byteLength);
        const heap8 = new Uint8Array(wasmExports.memory.buffer);
        const heap32 = new Uint32Array(wasmExports.memory.buffer);
        const heap16 = new Int16Array(wasmExports.memory.buffer);
        heap8.set(modfiledata, memaddr);

        const audioCtx = new AudioContext();
        
        wasmExports.loadModule(memaddr, modfiledata.byteLength, audioCtx.sampleRate);

        let startTime = audioCtx.currentTime + 0.5;
        const playFragment = () => {
            const frameinfo = wasmExports.playFrame();
            const bufptr = heap32[(frameinfo / 4) + 10] / 2;
            const bufsize = heap32[(frameinfo / 4) + 11] / 2;

            const audiodata = heap16.subarray(bufptr, bufptr + bufsize);

            const durationFrames = bufsize / 2;
            const leftBuffer = new Float32Array(durationFrames);
            const rightBuffer = new Float32Array(durationFrames);

            const pow2_15 = Math.pow(2, 15);

            for (let n=0;n<audiodata.length;n+=2) {
                const bufIndex = n / 2;
                leftBuffer[bufIndex] = audiodata[n] / pow2_15;
                rightBuffer[bufIndex] = audiodata[n+1] / pow2_15;
            }

            const audioBuf = audioCtx.createBuffer(2, durationFrames, audioCtx.sampleRate);
            audioBuf.getChannelData(0).set(leftBuffer);
            audioBuf.getChannelData(1).set(rightBuffer);
            const audioBufSrcNode = audioCtx.createBufferSource();
            audioBufSrcNode.buffer = audioBuf;
            audioBufSrcNode.connect(audioCtx.destination);
            audioBufSrcNode.loop = false;
            audioBufSrcNode.start(startTime);            
            const durationSeconds = durationFrames / audioCtx.sampleRate;
            startTime += durationSeconds;
            return durationSeconds;
        };
        while ( lastFileInputChangeEvent == fileInputChangeEvent ) {
            const fragmentDurationSeconds = playFragment();
            await new Promise(resolve => setTimeout(() => resolve(), fragmentDurationSeconds * 1000 * 0.5));
        }
        audioCtx.close();
    })
</script>
</html>
```

# Using Emscripten runtime APIs

We said earlier, that Emscripten should let write programs similar to any other portable C/C++ code. In the previous example we wrote the audio and file interfacing in Javascript. It is possible to write these parts in C, since Emscripten has a file system and OpenAL audio API that we can interface with directly from C.

Let us see how we can implement even more of the mod player from the previous example in C.

The C program below is almost identical to how we would have written it as a console program. It accepts a filename as an argument, and plays the module file that we pass. It use OpenAL to output audio. The only difference is the use of `emscripten_sleep` in the main loop. The reason for this is that we don't want to block the browsers main loop, which would cause the user interface to not respond, and also waste energy. We just wait for a few milliseconds between each rendering of audio buffers.

To not block the browsers main loop, it also means that the WebAssembly program needs to exit Javascript for the pauses. Given that we are calling a main function on the WebAssembly binary, we would normally expect this to run until it's finished, but this is not the case when we use `emscripten_sleep`. Using `emscripten_sleep` will exit to Javascript, and call back into and continue WebAssembly execution when the pause is finished. This way of pausing and resuming, is not a standard feature of WebAssembly, and is made possible using the `ASYNCIFY` feature of emscripten. "Asyncify" works in the way that it's enhancing the code with functionality for pausing and resuming, keeping the execution state during the pauses. This comes with a cost of significantly increased size of the Wasm binary, but it let us write asynchronuous code in a synchronuous way.

By writing almost all the player code in C, we have also used several features of the Emscripten runtime environment. In addition to Asyncify and OpenAL for audio, we are also using the file system and `stdio`. Most of this is provided by the Javascript file that Emscripten generates together with the WebAssembly binary file.

Here is the module player in C:

```c
#include <stdio.h>
#include <stdlib.h>
#include <AL/al.h>
#include <AL/alc.h>
#include <xmp.h>

#define BUFFER_SIZE 4096
#define NUM_BUFFERS 4
#define SAMPLERATE 44100

int main(int argc, char **argv) {
    xmp_context context;
    struct xmp_frame_info frame_info;
    ALuint source, buffers[NUM_BUFFERS];
    ALCdevice *device;
    ALCcontext *alcContext;
    short buffer[BUFFER_SIZE];
    int ret, state;

    // Check command-line arguments
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <modfile>\n", argv[0]);
        return EXIT_FAILURE;
    }

    // Initialize OpenAL
    device = alcOpenDevice(NULL); // Open default device
    if (!device) {
        fprintf(stderr, "Failed to open OpenAL device\n");
        return EXIT_FAILURE;
    }

    alcContext = alcCreateContext(device, NULL);
    alcMakeContextCurrent(alcContext);

    // Generate OpenAL buffers and source
    alGenBuffers(2, buffers);
    alGenSources(1, &source);

    // Create a new libxmp context
    context = xmp_create_context();
    if (context == NULL) {
        fprintf(stderr, "Failed to create libxmp context\n");
        return EXIT_FAILURE;
    }

    // Load module
    ret = xmp_load_module(context, argv[1]);
    if (ret < 0) {
        fprintf(stderr, "Failed to load module: %s\n", argv[1]);
        xmp_free_context(context);
        return EXIT_FAILURE;
    }

    // Start playing with libxmp
    ret = xmp_start_player(context, SAMPLERATE, 0);
    if (ret < 0) {
        fprintf(stderr, "Failed to start player\n");
        xmp_release_module(context);
        xmp_free_context(context);
        return EXIT_FAILURE;
    }

    // Initial buffer filling
    for (int i = 0; i < NUM_BUFFERS; i++) {
        xmp_play_buffer(context, buffer, BUFFER_SIZE, 0);
        alBufferData(buffers[i], AL_FORMAT_STEREO16, buffer, BUFFER_SIZE, SAMPLERATE);
        alSourceQueueBuffers(source, 1, &buffers[i]);
    }

    alSourcePlay(source);

    // Main loop
    while (1) {
        alGetSourcei(source, AL_SOURCE_STATE, &state);
        if (state == AL_STOPPED)
            break;

        int processed;
        alGetSourcei(source, AL_BUFFERS_PROCESSED, &processed);

        while (processed--) {
            ALuint bufid;
            alSourceUnqueueBuffers(source, 1, &bufid);

            xmp_play_buffer(context, buffer, BUFFER_SIZE, 0);
            alBufferData(bufid, AL_FORMAT_STEREO16, buffer, BUFFER_SIZE, SAMPLERATE);
            alSourceQueueBuffers(source, 1, &bufid);
        }

        if (state != AL_PLAYING) {
            alSourcePlay(source);
        }

        emscripten_sleep(10);
    }

    // Cleanup
    xmp_end_player(context);
    xmp_release_module(context);
    xmp_free_context(context);

    alDeleteSources(1, &source);
    alDeleteBuffers(2, buffers);
    alcMakeContextCurrent(NULL);
    alcDestroyContext(alcContext);
    alcCloseDevice(device);

    return EXIT_SUCCESS;
}
```

And we compile it like this:

`emcc -sEXPORTED_RUNTIME_METHODS=FS,callMain,abort -sASYNCIFY -I./include lib/libxmp.a ./modplayer2.c -O3 -o modplayer2.mjs`

Let us go through the parameters we have set for this compile command.

The flag `-sEXPORTED_RUNTIME_METHODS` defines which of the runtime methods that should be exported so that they can be used in Javascript. We export `FS` which is the file system, `callMain` which allows us to call the `main` entry method of the C program, and `abort` which is a simple way of just stopping the program execution, which we will use when the user selects another mod file to play.

The next flag is `-sASYNCIFY` which turns on the Asyncify feature of Emscripten. This feature generates a larger Wasm binary, so applying the optimization flag `-O3` helps to keep the size down to as little as possible.

We add the include path, and link the static library `libxmp.a`.

Finally take note of the output file name `modplayer2.mjs`. We use the `mjs` extension since we want to have an ECMAScript module which will give us more compact and readable Javascript code for interacting with the WebAssembly.

When we have compiled we can write a HTML file that is quite smaller than the one we had in the previous example. Now we don't need to initialize Web Audio, or write the file contents to Wasm memory. Neither do we have to extract buffers and send to the audio interface. All of this is now done in the C program, and Emscripten provides the interfaces to the Web APIs we need. We only have to write the mod file to the Emscripten file system, which we do before calling `main`.

The following code shows the HTML file where we leave it to the Emscripten Javascript runtime and the compiled WebAssembly binary to set up the Web Audio context. We simply take the mod file uploaded by the user, and write it to the Emscripten file system. Finally we call the main function with the mod file name as argument, and the rest is then handled by the Emscripten Javascript runtime, and the WebAssembly application.

```html
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
    <input type="file" id="modfileinput">
</body>
<script type="module">
    const modfileinput = document.getElementById('modfileinput');
    let modplayer;
    modfileinput.addEventListener('change', async (fileInputChangeEvent) => {
        if (modplayer) {
            try {
                modplayer.abort();
            } catch(e) {}
        }
        const file = modfileinput.files[0];
        const filereader = new FileReader();
        const modfiledata = await new Promise(resolve => {
            filereader.onload = e => resolve(new Uint8Array(e.target.result));
            filereader.readAsArrayBuffer(file);
        });

        const jsmodule = await import(new URL('modplayer2.mjs', import.meta.url));
        modplayer = await jsmodule.default({noInitialRun: true});
        modplayer.FS.writeFile(file.name, modfiledata);
        modplayer.callMain( [file.name]);
    })
</script>
</html>
```

# Wasi, the WebAssembly System Interface

In the examples above, we either did not use operating system functions, or we accessed them through the Emscripten Javascript runtime. The Emscripten runtime facilitates using features such as standard input/output, files and networking in a web browser or from nodejs. If we don't want to use a browser or nodejs as WebAssembly host, then we don't have the Javascript runtime for providing interfaces to operating system features. WASI, the WebAssembly System Interface, which we will look deeper into in a later chapter, is a standard defining WebAssembly imports we can use for this kind of interaction. WebAssembly modules implementing the WASI specification can run on a number of Wasm runtimes.

Let us try a basic example of compiling a standalone Wasm without a Javascript runtime to host it. We will go back to the hello world example we started with in the beginning of this chapter:

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("Hello %s\n", argv[argc-1]);
    return 0;
}
```

We can compile it, just like we compile with gcc:

`emcc -o helloworld.wasm helloworld.c`

and we can run it with a WebAssembly runtime like for example "wasmtime" (which you can find at https://wasmtime.dev/).

In a terminal we can type the following:

```bash
wasmtime helloworld.wasm Peter
```

which outputs `Hello Peter`

Looking at the generated WebAssembly, it contains the following imports:
```
(import "wasi_snapshot_preview1" "args_sizes_get" (func (;0;) (type 2)))
(import "wasi_snapshot_preview1" "args_get" (func (;1;) (type 2)))
(import "wasi_snapshot_preview1" "proc_exit" (func (;2;) (type 3)))
(import "wasi_snapshot_preview1" "fd_write" (func (;3;) (type 5)))
```

These are imports according to the WASI specification, and in this case it is imports for getting the arguments, writing to file descriptors ( used for writing to `stdout` ), and exiting the program.

Another thing to notice in the generated WebAssembly binary is the export `_start`. This is the entry point for a WASI WebAssembly module and is where we find the main method.

## Using Wasi with the file system

Below is a very simple C++ program that reads a file. We can also use WASI for this so that we can connect to the real file system of the operating system.

```c++
#include <iostream>
#include <fstream>
#include <string>

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <filename>\n";
        return 1;
    }

    std::ifstream file(argv[1]);

    if (!file.is_open()) {
        std::cerr << "Error opening file: " << argv[1] << std::endl;
        return 1;
    }

    std::string line;
    while (std::getline(file, line)) {
        std::cout << line << std::endl;
    }

    file.close();

    return 0;
}
```

We are able to compile this with emscripten, but at the time of writing the WASI support is limited, and the compiled program will not be able to open the file. If we rather compile it with `wasi-sdk` then we are able to make it work.

To use the wasi-sdk we first need to download and extract it, and find the `sysroot` folder, which we will use as an input to the compiler. This folder contains all the include files for the standard library ( libc ), which is implemented specifically for Wasi.

`clang++ --target=wasm32-wasi --sysroot=wasi-sdk-20.0/share/wasi-sysroot printfile.cpp -o printfile.wasm`

Again we use `wasmtime` for running this, but this time we need to add the capability for interacting with files in the current directory. We do that by providing the `--dir` parameter.

`wasmtime --dir . printfile.wasm printfile.cpp`

This will print the contents of `printfile.cpp` to the console.

# Interact with Javascript from within C / C++

Back to Emscripten, one of its main strengths is the interaction with Javascript. When porting applications to run in the browser, we need several integrations to the Web APIs. This is also the case if running on the server side with nodejs as the WebAssembly host.

This can be particularly useful when porting applications to the web, if we for example need to interact with Web APIs in the middle of a WebAssembly function call. We are going to look into a concrete example on this in the next chapter, but right here we will just demonstrate how the feature works. Let us create a simple C++ program that calls back to Javascript setting the background color of the page.

```c++
#include <emscripten.h>
#include <cmath>
#include <ctime>

// Global variables for the RGB components
float r = 0, g = 0, b = 0;

// Function to update the RGB values based on sine wave
void updateColors() {
    // Current time in seconds
    float time = static_cast<float>(clock()) / CLOCKS_PER_SEC;

    // Sine wave parameters: amplitude, frequency, and phase offset
    float amplitude = 127.5;
    float frequency = 1.0;
    
    // Update r, g, b values based on sine wave with different phase offsets
    r = amplitude * (sin(frequency * time) + 1.0); // No offset for red
    g = amplitude * (sin(frequency * time + 2.0944) + 1.0); // 120 degrees offset for green
    b = amplitude * (sin(frequency * time + 4.18879) + 1.0); // 240 degrees offset for blue
}

// Function to change the background color
void changeBackground() {
    EM_ASM({
        document.querySelector('body').style.backgroundColor = `rgb(${$0},${$1},${$2})`;
    }, static_cast<int>(r), static_cast<int>(g), static_cast<int>(b));
}

// Main loop function
void mainLoop() {
    updateColors();
    changeBackground();
}

int main() {
    // Set the main loop to run at 60 fps
    emscripten_set_main_loop(mainLoop, 60, 1);

    return 0;
}
```

We compile this so that we also get an html file generated for us:

`em++ jscallback.cpp -o jscallback.html`

And if we open the HTML page, we can see that the background color is changing smoothly over time, the color components `r`, `g` and `b` are calculated from a sine function of the current time. We see in the `changeBackground` function, that we have Javascript code inside `EM_ASM`, which is setting the `backgroundColor` on the `body` element of the page.

# Working around limitations

Emscripten helps us far on the way to let us use standard C libraries to access various system features. Still, when compiling WebAssembly for running in the browser or in NodeJS we may need to supply with special code for adapting to the runtime environment and handling the limitations. Javascript is asynchronuous, meaning that there are no waiting code blocks that halts execution to wait for an external event. Instead, all events trigger a code block execution. This contradicts the way we for example write networking code in C, where a thread waits for data to appear.

When connecting to network resources in C/C++ it is common to use POSIX TCP sockets if targeting Linux or Unix platforms. For windows there is the Winsock API. For cross-platform codebases we often see implementations for both of these APIs. Quite a bit of code is needed for network interaction using these low level APIs. Even though Emscripten supports many Linux/Unix libraries, as we saw in the audio example above, there are cases where we should consider replacing such platform specific code with Javascript.

Consider the following minimal example in C++, using POSIX TCP sockets, to print the result of connecting to the public REST API endpoint https://jsonplaceholder.typicode.com/posts/1.

```c++
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

#define BUFFER_SIZE 1024

int main() {
    struct addrinfo hints, *res;
    int sockfd;
    char buffer[BUFFER_SIZE];

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC; // Allow IPv4 or IPv6
    hints.ai_socktype = SOCK_STREAM; // TCP stream sockets

    getaddrinfo("jsonplaceholder.typicode.com", "80", &hints, &res);

    sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    connect(sockfd, res->ai_addr, res->ai_addrlen);
    freeaddrinfo(res);

    const char *http_request = "GET /posts/1 HTTP/1.1\r\nHost: jsonplaceholder.typicode.com\r\nConnection: close\r\n\r\n";
    send(sockfd, http_request, strlen(http_request), 0);

    int bytes_received;
    while ((bytes_received = recv(sockfd, buffer, BUFFER_SIZE - 1, 0)) > 0) {
        buffer[bytes_received] = '\0';
        std::cout << buffer;
    }

    close(sockfd);
    return 0;
}
```

Even though we try to make it as minimal as possible in C++ with POSIX TCP sockets, we can see that it is quite comprehensive to set up the connection, send the request data, and then store the data chunks in the buffer for printing to the console. 

Now, see how easily the same written in Javascript can be expressed in one line:

```javascript
console.log(await fetch('https://jsonplaceholder.typicode.com/posts/1').then(r => r.text()))
```

To support code using POSIX TCP sockets, Emscripten emulates it by using WebSockets. For this to be working you will also need a WebSocket handler on the server side, that will act as a proxy to the real TCP socket endpoint. If the case is that we need to connect to a TCP socket endpoint, then this is the best option. However, often the network endpoints modern applications connects to today are HTTP endpoints. Since Javascript offers better and easier methods for connecting to HTTP endpoints than using low level POSIX TCP sockets, we can adapt to that instead of setting up the infrastructure with a WebSocket proxy for being able to support POSIX TCP socket code. Even though Emscripten offers such a proxy, it is more efficient and performant to adapt to the browsers functions for interacting with HTTP endpoints. In this chapter and the next, we will focus on this way of implementing networking with Emscripten.

Since we can call Javascript from Emscripten, we can use the `fetch` function from our C++ code. It becomes much simpler then, and more efficient since now our browser code connects directly to the API that we want to interact with.

Here we also use `Asyncify` to handle the asynchronuous behaviour of Javascript `fetch`:

```c++
#include <emscripten.h>
#include <iostream>

EM_ASYNC_JS(const char*, fetch_example, (), {
    const data = await fetch('http://jsonplaceholder.typicode.com/posts/1').then(response => response.text());
    const lengthBytes = lengthBytesUTF8(data) + 1;
    const stringOnWasmHeap = _malloc(lengthBytes);
    stringToUTF8(data, stringOnWasmHeap, lengthBytes);
    return stringOnWasmHeap;
});

int main() {
    const char* data = fetch_example();
    std::cout << data << std::endl;
    return 0;
}
```

To compile this with Emscripten we can use the following command:

```bash
em++ -o index.html -sEXPORTED_FUNCTIONS=_malloc,_main -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='$lengthBytesUTF8','$stringToUTF8' -sASYNCIFY=1 main.cpp
```

When loading this into the browser, we can see the results from the external site. If we inspect the network traffic in the browser console, we can also see that there is a direct call to the external API resource.

In the next chapter, we will look into converting an existing codebase that connects to HTTP endpoints using sockets. There we will also see how we can use the approach described here, to rewrite the networking part to use built-in functions in the browser.

# Conclusion

In this chapter, we have got a brief introduction to Emscripten that let us compile C and C++ code for use with WebAssembly in a Web browser or run in nodejs. We have seen how we can write applications in C or C++ and interact with Web browser features, also even without writing Javascript code to connect with WebAssembly. The Javascript API of Emscripten provides several implementations of C/C++ APIs that are connected directly to Web Browser features such as audio or canvas drawing. Emscripten comes with a toolchain that let us use the same configuration and compile flow as when building native applications, which is demonstrated by porting the library `libxmp` that is not originally made for use in a Web browser. Here we also saw that we can run WebAssembly in an asyncrhonous way with the `ASYNCIFY` feature. We have also briefly looked at Wasi which enables us to interact with system features with other WebAssembly hosts than Javascript. Finally the Javascript interaction features of Emscripten were demonstrated, where we saw a callback to Javascript for changing properties of the HTML page.

In the next chapter we will build on what we have learned here to compile the well known C library libgit2 to WebAssembly. Compiling such a large codebase is a complex excercise, but by utilizing what we have looked into here when it comes to combining JavaScript features, we can make almost any C/C++ library work in the browser or NodeJS environment. Porting C libraries to the browser, and especially libgit2, opens up for new interesting use cases. A git file system that lives on the end users device, can provide the performant user experience of a local desktop application, and still be able to synchronize with a remote server to store user data centrally.

# Points to remember

- Emscripten let us compile C and C++ to WebAssembly, but also provides Javascript to connect to Web or NodeJS APIs.
- The `ASYNCIFY` feature can call into WebAssembly, pause and resume execution to simulate asynchronous execution
- Wasi provides operating system bindings without Javascript as a connecting layer
- One of the strengths with Emscripten is the possibility to call back into Javascript from within the middle of Wasm execution
